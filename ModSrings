/ Given a subset C of G, returns Aut(G)(C), i.e. the union of
// automorphism classes represented in C.

AutoClass := function(C,G);

	repeat
		oldC := C;
		for g in Generators(AutomorphismGroup(G)) do
			C := C join g(C);
		end for;
	until #oldC eq #C;
	return C;
end function;


// Returns a sequence of sets, the automorphism classes of a group G.

AutoClasses := function(G);

	classes := [ {G!1} ];
	H := Set(G) diff {G!1};
	while H ne {} do
		class := {Random(H)};
		class := AutoClass(class,G);
		classes := Append(classes,class);
		H := H diff class;
	end while;
	return classes;
end function;


// Given a collection ‘classes’ of subsets of G, returns the sequence of
// subgroups generated by any subcollection of ‘classes’.

GenSubgroups := function(classes,G);

	cgroups := [];
	for c in classes do
		Include(~cgroups,sub<G | c>);
	end for;

	newgroups := Set(cgroups);
	repeat
		oldgroups := Set(cgroups);
		for c in newgroups do
			for d in cgroups do
				Include(~cgroups,sub<G | c,d>);
			end for;
		end for;
		newgroups := Set(cgroups) diff oldgroups;
	until newgroups eq {};
	return cgroups;
end function;


// Returns a sequence of all characteristic subgroups of G

CharSubgroups := function(G);

	return GenSubgroups(AutoClasses(G),G);
end function;


// Given a subset C of a group, returns the sum of the elements of C
// in the group algebra ’alg’.

Bar := function(C,alg);

	return alg ! [(i in C) select 1 else 0 : i in {1 .. Dimension(alg)}];
end function;


// Given an element ’x’ of an algebra ’alg’, returns x^(-1).
// ’inv’ must be a list giving the inverses of the basis elements of ’alg’.

Inv := function(x,alg,inv);

	c := Eltseq(x);
	for i:=1 to #inv do
		if inv[i] gt i then
			a:=c[i];
			c[i]:=c[inv[i]];
			c[inv[i]]:=a;
		end if;
	end for;
	return alg ! c;
end function;


// Given an element ’x’ of an algebra ’alg’, returns the list of coordinates
// of ’x’ with respect to the S-ring ’sring’ (’x’ must actually be in this S-ring
// or an error will be generated), where ’sring’ is represented as a list of
// basic sets, each basic sets being represented as a set of integers
// in the range 1..Dimension(alg).

Coords := function(x,sring,alg);

	coords := [];
	for i:=1 to #sring do
		j := Random(sring[i]);
		Append(~coords,x[j]);
		x := x-x[j]*Bar(sring[i],alg);
	end for;
	if x ne alg!0 then
		error "x not in S-ring.";
	end if;
	return coords;
end function;


// Internal routine used in SRings:
// Given a group ’G’, returns the group algebra of G as a structure constant algebra,
// along with several other items:
// inv: list of integers in the range 1..#G giving the inverse of each element of G
// GG: list of elements of ’G’ (in the order used by the preceding ’inv’)
// GI: associative array giving, for each element ’g’ of G, the integer associated
// with ’g’, so that GG[GI[g]] equals g and GI[GG[i]] equals i.

GroupAlg := function(F,G);

	GG := [G!1] cat Setseq(Set(G) diff {G!1});
	if IsCyclic(G) then
		GG := [G.1^i : i in {0..#G-1}];
	end if;
	GI := AssociativeArray(G);
	for i:=1 to #GG do
		GI[GG[i]] := i;
	end for;
	alg := [];
	inv := [];
	for i:=1 to #GG do
		for j:=1 to #GG do
			Append(~alg,<i,j,GI[GG[i]*GG[j]],1>);
		end for;
		Append(~inv,GI[GG[i]^-1]);
	end for;
	return Algebra<F,#G | alg>,inv,GG,GI;
end function;


// Internal routine used in RationalAlg:
// Given the set of automorphism classes A of a group G, returns
// the discrete rational S-ring over G as a structure constant algebra.

CAlg := function(A,G);

	inv := [];
	for i:=1 to #A do
		g := Random(A[i]);
		for j:=1 to #A do
			if g in A[j] then
				Append(~inv,j);
				continue i;
			end if;
		end for;
		error "Problem with inv in RationalAlg.";
	end for;
	alg := [];
	for i:=1 to #A do
		for j:=1 to #A do
			for k:=1 to #A do
				g := Random(A[k]);
				S := {g*h : h in A[inv[j]]};
				Append(~alg,#(A[i] meet S));
			end for;
		end for;
	end for;
	return Algebra<RationalField(),#A | alg>,inv;
end function;


// Returns the discrete rational S-ring over G as an algebra.

RationalAlg := function(G);

	A := AutoClasses(G);
	GA,inv := CAlg(A,G);
	return GA,inv,A;
end function;


// Internal routine used by MergeClasses:

JoinClasses := function(classes,mtab,k1,k2);

	for i:=1 to #classes do
		if i eq k2 then continue; end if;
		mtab[i][k1] +:= mtab[i][k2];
		mtab[k1][i] +:= mtab[k2][i];
	end for;
	mtab[k1][k1] +:= mtab[k2][k2];
	classes[k1] := classes[k1] join classes[k2];
	Remove(~classes,k2);
	Remove(~mtab,k2);
	for i:=1 to #classes do
		Remove(~mtab[i],k2);
	end for;
	return classes,mtab;
end function;


// Internal routine used by SRingsRec:
// Given a sequence ‘classes’ of disjoint sets of group elements,
// beginning with classes[i] all classes which intersect
// ‘class’ are merged into a single class.

MergeClasses := procedure(class,~mtab,~classes,~j,~j0,~succ);

	succ := true;
	i := j;
	j := 0;
	for k:=i to #classes do
		if class meet classes[k] ne {} then
			if class eq classes[k] then return; end if;
			classleft := class diff classes[k];
			l:=k+1;
			if k eq i then l:=j0; end if;
			while l le #classes and classleft ne {} do
				if classleft meet classes[l] ne {} then
					classleft := classleft diff classes[l];
					classes,mtab := JoinClasses(classes,mtab,k,l);
					if l lt j0 then j0 := j0-1; end if;
				else
					l := l+1;
				end if;
			end while;
			succ := classleft eq {};
			j:=k;
			return;
		end if;
	end for;
end procedure;


// Internal routine used in SRings:

forward SRingsRec;
SRingsRec := procedure(classes,mtab,i,j0,alg,inv,~srings);

	j := i;
	while j ne 0 and j lt #classes do
		class := { inv[k] : k in classes[j] };
		j := i;
		MergeClasses(class,~mtab,~classes,~j,~j0,~succ);
		if not succ then return; end if;
		if j lt i and j ne 0 then return; end if;
	end while;
	while i le #classes do
		for j:=j0 to #classes do
			nclasses,nmtab := JoinClasses(classes,mtab,i,j);
			SRingsRec(nclasses,nmtab,i,j,alg,inv,~srings);
		end for;
		for j:=2 to i do
			for k:=2 to i do
				try
					c:=Coords(mtab[j][k],classes,alg);
					catch e
					return;
				end try;
			end for;
		end for;
		for j:=2 to i do
			class := { inv[k] : k in classes[j] };
			for k:=2 to #classes do
				if classes[k] eq class then continue j; end if;
			end for;
			return;
		end for;
		i := i+1;
		j0 := i+1;
	end while;
	Append(~srings,classes);
end procedure;


// Returns a list of all S-rings over a group G (if pseudo is set to ’true’, then all
// PS-rings are returned). Each S-ring is represented as a list of basic sets
// (beginning with the identity basic set), where each basic set is represented
// as a set of integers in the range 1..#G; these are indices into the list of group
// elements GG also returned.

SRings := function(F, G : pseudo:=false);

	GA,inv,GG,GI := GroupAlg(F,G);
	classes := [ {i} : i in {1 .. #inv} ];
	srings := [];
	a := pseudo select 1 else 2;
	SRingsRec(classes,BasisProducts(GA),a,a+1,GA,inv,~srings);
	return srings,GG;
end function;


// Returns a list of all rational S-rings over a group G. Each S-ring is represented
// as a list of basic sets (beginning with the identity basic set), where each basic
// set is represented as a set of integers which are indices into the list of
// automorphism classes A of G which is also returned.

RationalSRings := function(G);

	GA,inv,A := RationalAlg(G);
	classes := [ {i} : i in {1 .. #inv} ];
	srings := [];
	SRingsRec(classes,BasisProducts(GA),2,3,GA,inv,~srings,false);
	return srings,A;
end function;


// Given an S-ring ’sring’ over a group G, returns the list of S-rings over G which
// are strongly isomorphic to ’sring’.

AutoSRings := function(sring,G : A:=AutomorphismGroup(G));

	srings := {sring};
	repeat
		n := #srings;
		newsrings := {};
		for S in srings do
			newsrings join:= {{{(A.i)(g) : g in C} : C in S} : i in
			{1..NumberOfGenerators(A)}};
		end for;
		srings join:= newsrings;
	until n eq #srings;
	return srings;
end function;


// Given a list ’srings’ of S-rings over a group G, returns a set of representatives
// from each strong isomorphism class occuring in ’srings’.

AutoReps := function(srings,G);

	reps := {};
	A := AutomorphismGroup(G);
	while #srings gt 0 do
		print #srings;
		sring := Random(srings);
		srings := srings diff AutoSRings(sring,G : A:=A);
		reps join:= {sring};
	end while;
	return reps;
end function;


// ------------------------------------------------------------------------------
// The remaining routines deal with S-rings which may be constructed using
// type (I), (II), and (III) constructions. In these routines, the S-rings are
// represented as lists of basic sets, where the basic sets are subsets of the
// group (instead of sets of integer indices into the group as above).
// ------------------------------------------------------------------------------
// Given an S-ring ’S’, returns whether a subset H of the underlying group is
// an S-set.

IsSSet := function(S,H);

	for C in S do
		if #(C meet H) gt 0 then
			if not C subset H then return false; end if;
			H := H diff C;
		end if;
	end for;
	return true;
end function;


forward SRing0;
forward SRings1;
forward SRings2;
forward SRings3;


// Returns the set of S-rings over a group G which may constructed recursively using
// type (I), (II), and (III) constructions.

SRings123 := procedure(G,~tab,~ans);

	CG := CyclicGroup(#G);
	b,iso := IsIsomorphic(CG,G);
	t := iso(CG.1);
	if IsDefined(tab,#G) then	
		ans := {{{t^i : i in C} : C in S} : S in tab[#G]};
		return;
	end if;
	S0:={SRing0(G)};
	S1:=SRings1(G);
	SRings2(G,~tab,~S2);
	SRings3(G,~tab,~S3);
	ans := S0 join S1 join S2 join S3;
	GI := AssociativeArray();
	for i:=0 to #G-1 do GI[t^i]:=i; end for;
	tab[#G] := {{{GI[g] : g in C} : C in S} : S in ans};
end procedure;


// Returns the trivial S-ring over a group G.

SRing0 := function(G);

	if #G ne 1 then return {{G!1},Set(G) diff {G!1}};
	else return {{G!1}}; end if;
end function;


// Returns the type (I) S-rings over a group G.
// (or rather, a complete set of strong automorphism representatives of
// type (I) S-rings, which, in case G is cyclic, is the complete set
// of type (I) S-rings.)

SRings1 := function(G);

	A := AutomorphismGroup(G);
	map,AA := PermutationRepresentation(A);
	srings := {};
	SS := Subgroups(AA);
	for i:=1 to #SS do
		H := (map^-1)(Generators(SS[i]‘subgroup));
		sring := {};
		elts := Set(G);
		while #elts gt 0 do
			C := {Random(elts)};
			repeat
				n := #C;
				C join:= {h(c) : h in H, c in C};
			until #C eq n;
			elts := elts diff C;
			sring join:= {C};
		end while;
		srings join:= {sring};
	end for;
	return srings;
end function;


// Returns the type (II) S-rings over a group G.

SRings2 := procedure(G,~tab,~srings);

	NN := {N : N in NormalSubgroups(G) | not #N in {1,#G}};
	NN1 := {N : N in NN | (#N)^2 le #G};
	srings := {};
	for N1 in NN1 do
		for N2 in NN do
			if #(N1 meet N2) eq 1 and sub<G|N1,N2> eq G then
				SRings123(N1,~tab,~srings1);
				SRings123(N2,~tab,~srings2);
				for S1 in srings1 do
					for S2 in srings2 do
						srings join:= {{{c*d : c in C,d in D} : C in S1, D in S2}};
					end for;
				end for;
			end if;
		end for;
	end for;
end procedure;


// Returns the type (III) S-rings over a group G.

SRings3 := procedure(G,~tab,~srings);

	KK := {K‘subgroup : K in Subgroups(G) | #K‘subgroup ne #G};
	HH := {H : H in NormalSubgroups(G) | not #H in {1,#G}};
	srings := {};
	for K in KK do
		for H in HH do
			if not H subset K then continue; end if;
			SRings123(K,~tab,~srings1);
			Q,phi := quo<G|H>;
			SRings123(Q,~tab,~srings2);
			for S1 in srings1 do
				if not IsSSet(S1,Set(H)) then continue; end if;
				for S2 in srings2 do
					SK1 := {{phi(g) : g in C} : C in S1};
					SK2 := {C : C in S2 | C subset phi(K)};
					if SK1 eq SK2 then
						S := S1 join {{(phi^-1)(g)*h : g in C, h in H} : C in S2 |
						not C subset phi(K)};
						srings join:= {S};
					end if;
				end for;
			end for;
		end for;
	end for;
end procedure;
