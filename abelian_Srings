// The goal of this program sheet is to write an efficient algorthim to compute all the srings of a finite abelian group. 
// I begin this goal by constructing all the lattice srings of an abelian group.

// Given lattice elements "a" and "b" of the same lattice L, returns the lattice-meet of "a" and "b".

LatticeMeet := function(a, b);
	
	m := a;		//"m" is always a factor of "a". The function terminates when "m" eventually becomes a factor of "b", which must be the greatest common factor.
	S := {a};	// "S" is the set of potential common factors.
	T := {};	// "T" is the set of future potential common factors.

	while (not m le b) do
		S diff:= {m};			// Since "m" is not a common factor, it is removed, and will be replaced by its factors if no other common factor is found first.
		T join:= MaximalSubgroups(m);

		if S eq {} then 		// If "S" is exhausted, then search amongst the next generation factors.
			S := T;
			T := {};
		end if;

		m := Representative(S);				
	end while;

	return m;
end function;

// Given lattice elements "a" and "b" of the same lattice L, returns the lattice-join of "a"
// and "b".

LatticeJoin := function(a, b);
	
	m := a;					//"m" is always a factor of "a". The function terminates when "m" eventually becomes a multiple of "b", which must be the least common multiple.
	S := {a};				// "S" is the set of potential common multiples.
	T := {};				// "T" is the set of future potential common multiples.

	while (not m ge b) do
		S diff:= {m};			// Since "m" is not a common multiple, it is removed, and will be replaced by its multiples if no other common multiple is found first.
		T join:= MinimalOvergroups(m);	 

		if S eq {} then 		// If "S" is exhausted, then search amongst the next generation multiples.
			S := T;			
			T := {};		
		end if;

		m := Representative(S);					
	end while;

	return m;
end function;

MultiLatticeMeet := function(A);

	m := Representative(A);
	for a in A do
		m := LatticeMeet(m,a);
	end for;
	return m;
end function;

MultiLatticeJoin := function(A);

	m := Representative(A);
	for a in A do
		m := LatticeJoin(m,a);
	end for;
	return m;
end function;


// This function returns the lattice of subgroups generated by the collection of "subgroups" 
// of the group "G". "subgroups" should be represented as a set of subsets of "G". "G" and 
// the trivial subgroup are always considered to be elements of "subgroups."

LatticeGeneratedBy := function(subgroups, L);
	subgroups join:= {Bottom(L), Top(L)};

	MoreSubgroups := subgroups;

	for H in subgroups do

		MoreSubgroups join:= {LatticeMeet(H, K) : K in L} join {LatticeJoin(H,K) : K in L};	
	

	return subgroups;
end function;
